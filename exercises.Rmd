---
title: SQL Exercises
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

<style>
.title {
  margin-bottom: 0; /* Reduces space below the title */
}
.author {
  margin-top: 0; /* Reduces space above the author */
}
</style>

<div class="title">
  <h1>SQL Exercises on Seattle and Portland Flights data</h1>
</div>
<div class="author">
  <h3>Author: Dr. Chester Ismay</h3>
</div>

```{r setup, include=FALSE}
library(learnr)
suppressPackageStartupMessages(library(gradethis))
library(DBI)
library(RSQLite)
suppressPackageStartupMessages(library(tidyverse))

# Copy data over into this folder
# file.copy(from = "../flights2023/pnwflights23/data/airlines.rda", 
#           to = "data/airlines.rda")
# file.copy(from = "../flights2023/pnwflights23/data/airports.rda",
#           to = "data/airports.rda")
# file.copy(from = "../flights2023/pnwflights23/data/flights.rda",
#           to = "data/flights.rda")
# file.copy(from = "../flights2023/pnwflights23/data/planes.rda",
#           to = "data/planes.rda")
# file.copy(from = "../flights2023/pnwflights23/data/weather.rda",
#           to = "data/weather.rda")

# Read data in from RDA files
load("data/airlines.rda")
load("data/airports.rda")
load("data/flights.rda")
load("data/planes.rda")
load("data/weather.rda")

## Create an ephemeral in-memory RSQLite database
con <- dbConnect(SQLite(), ":memory:")

# Write the new data to the database
dbWriteTable(con, "airlines", airlines, overwrite = TRUE)
dbWriteTable(con, "airports", airports, overwrite = TRUE)
dbWriteTable(con, "flights", flights, overwrite = TRUE)
dbWriteTable(con, "planes", planes, overwrite = TRUE)
dbWriteTable(con, "weather", weather, overwrite = TRUE)

knitr::opts_chunk$set(connection = "con", 
                      max.print = 20)
```

```{r setup2, echo=FALSE, out.width='100%', fig.align='center'}
tutorial_options(exercise.cap = "Query", 
                 exercise.eval = FALSE,
                 exercise.reveal_solution = TRUE)

library(DiagrammeR)
# https://github.com/bergant/datamodelr
library(datamodelr)

dm_f <- dm_from_data_frames(airlines, airports, flights, planes, weather)

dm_f <- dm_add_references(
  dm_f,
  
  flights$carrier == airlines$carrier,
  flights$origin == airports$faa,
  flights$dest == airports$faa,
  flights$tailnum == planes$tailnum,
  weather$origin == airports$faa
)

graph <- dm_create_graph(dm_f, rankdir = "BT", col_attr = c("column", "type"))

dm_render_graph(graph)
```

<style>
.small-yellow-btn {
padding: 5px 10px; /* Adjust padding to reduce size */
font-size: 12px; /* Smaller font size */
border-radius: 5px; /* Adjust border radius for rounded corners */
background-color: yellow; /* Set background color to yellow */
color: black; /* Text color */
border: 1px solid darkgray; /* Optional: add border */
}
</style>

<style>
.hint-container {
margin-left: 40px; /* Adjust indentation as needed */
}
</style>

# Selection Techniques

## Selecting columns/fields

1. Select all airline names from the `airlines` table.

```{sql query1, exercise=TRUE, exercise.eval=FALSE}
-- Write your SQL query here to select all airline names from the airlines table
```

```{sql query1-hint-1}
-- HINT: The syntax for selecting all columns from a table is:
SELECT ___
FROM ___;
```

```{sql query1-hint-2}
-- HINT: The syntax for selecting specific columns from airlines is:
SELECT ___
FROM airlines;
```

```{sql query1-solution}
-- SOLUTION: Here's one way to select all airline names from the airlines table
SELECT name
FROM airlines;
```

```{r query1-check, echo=FALSE}
grade_this({
  # Execute the solution query to get the correct result
  .solution <- DBI::dbGetQuery(con, .solution_code)
  
  # Execute the student's query
  .result <- DBI::dbGetQuery(con, .user_code)
  
  # Dynamically get expected columns from the solution
  cols_expected <- names(.solution)
  
  # Check for missing or extra columns
  missing_cols <- setdiff(cols_expected, names(.result))
  extra_cols <- setdiff(names(.result), cols_expected)
  
  if (length(missing_cols) > 0) {
    fail(glue::glue("Your query is missing the following columns: {toString(missing_cols)}."))
  }
  
  if (length(extra_cols) > 0) {
    fail(glue::glue("Your query should not include the following columns: {toString(extra_cols)}."))
  }
  
  # Check for matching row counts
  if (nrow(.result) != nrow(.solution)) {
    fail("The number of rows returned by your query does not match the expected result.")
  }
  
  # Check if all values in each column match, allowing for different row orders
  all_columns_match <- TRUE
  for (column in cols_expected) {
    if (!identical(sort(.result[[column]]), sort(.solution[[column]]))) {
      all_columns_match <- FALSE
      break
    }
  }
  
  if (!all_columns_match) {
    fail("The values returned by your query do not match the expected result in one or more columns.")
  }
  
  # If all checks pass
  pass("Your query appears to be correct.")
})
```


2. Select all columns from the `weather` table.

```{sql query2, exercise=TRUE, exercise.eval=FALSE}
-- Write your SQL query here to select all columns/fields from the weather table
```

```{sql query2-hint-1}
-- HINT: Use SELECT * to select all columns from a table.
SELECT *
___ ___;
```

```{sql query2-hint-2}
-- HINT: Use FROM to specify which table to pull all columns from.
SELECT *
FROM ___;
```

```{sql query2-solution}
-- SOLUTION: Here is one way to select all fields from the `weather` table:
SELECT *
FROM weather;
```

```{r query2-check, echo=FALSE}
grade_this({
  # Execute the solution query to get the correct result
  .solution_ex2 <- DBI::dbGetQuery(con, .solution_code)
  
  # Execute the student's query
  .result_ex2 <- DBI::dbGetQuery(con, .user_code)
  
  # Use the grading logic from EXERCISE 1, adapted for EXERCISE 2
  # Dynamically get expected columns from the solution for EXERCISE 2
  cols_expected_ex2 <- names(.solution_ex2)
  
  # Check for missing or extra columns
  missing_cols_ex2 <- setdiff(cols_expected_ex2, names(.result_ex2))
  extra_cols_ex2 <- setdiff(names(.result_ex2), cols_expected_ex2)
  
  if (length(missing_cols_ex2) > 0) {
    fail(glue::glue("Your query is missing the following columns: {toString(missing_cols_ex2)}."))
  }
  
  if (length(extra_cols_ex2) > 0) {
    fail(glue::glue("Your query should not include the following columns: {toString(extra_cols_ex2)}."))
  }
  
  # Check for matching row counts
  if (nrow(.result_ex2) != nrow(.solution_ex2)) {
    fail("The number of rows returned by your query does not match the expected result.")
  }
  
  # Check if all values in each column match, allowing for different row orders
  all_columns_match_ex2 <- TRUE
  for (column in cols_expected_ex2) {
    if (!identical(sort(.result_ex2[[column]]), sort(.solution_ex2[[column]]))) {
      all_columns_match_ex2 <- FALSE
      break
    }
  }
  
  if (!all_columns_match_ex2) {
    fail("The values returned by your query do not match the expected result in one or more columns.")
  }
  
  # If all checks pass
  pass("Your query appears to be correct.")
})
```

3. Select the FAA code and name from the `airports` table.

```{sql query3, exercise=TRUE, exercise.eval=FALSE}
-- Write your SQL query here to select the FAA code and name from the airports table
```

```{sql query3-hint-1}
-- HINT: The syntax for selecting specific columns from a table is:
SELECT ___, ___
FROM ___;
```

```{sql query3-hint-2}
-- HINT: You need to specify the columns and table you're selecting from:
SELECT faa, ___
FROM airports;
```

```{sql query3-solution}
-- SOLUTION: Here is one way to select the FAA code and name from the airports table:
SELECT faa, name
FROM airports;
```

```{r query3-check, echo=FALSE}
grade_this({
  # Execute the solution query to get the correct result
  .solution_ex3 <- DBI::dbGetQuery(con, .solution_code)
  
  # Execute the student's query
  .result_ex3 <- DBI::dbGetQuery(con, .user_code)
  
  # Dynamically get expected columns from the solution for EXERCISE 3
  cols_expected_ex3 <- names(.solution_ex3)
  
  # Check for missing or extra columns
  missing_cols_ex3 <- setdiff(cols_expected_ex3, names(.result_ex3))
  extra_cols_ex3 <- setdiff(names(.result_ex3), cols_expected_ex3)
  
  if (length(missing_cols_ex3) > 0) {
    fail(glue::glue("Your query is missing the following columns: {toString(missing_cols_ex3)}."))
  }
  
  if (length(extra_cols_ex3) > 0) {
    fail(glue::glue("Your query should not include the following columns: {toString(extra_cols_ex3)}."))
  }
  
  # Check for matching row counts
  if (nrow(.result_ex3) != nrow(.solution_ex3)) {
    fail("The number of rows returned by your query does not match the expected result.")
  }
  
  # Check if all values in each column match, allowing for different row orders
  all_columns_match_ex3 <- TRUE
  for (column in cols_expected_ex3) {
    if (!identical(sort(.result_ex3[[column]]), sort(.solution_ex3[[column]]))) {
      all_columns_match_ex3 <- FALSE
      break
    }
  }
  
  if (!all_columns_match_ex3) {
    fail("The values returned by your query do not match the expected result in one or more columns.")
  }
  
  # If all checks pass
  pass("Your query appears to be correct.")
})
```

## Aliasing

4. Select and alias specific columns from the airports table

```{sql query4, exercise=TRUE, exercise.eval=FALSE}
-- Write your SQL query here to select the FAA code, name, 
-- and alt from the airports table with aliases of 
-- code, airport_name, and altitude, respectively
```


```{sql query4-hint-1}
-- HINT: Start by selecting columns and use AS to give them aliases. For example:
SELECT column_name AS alias_name
FROM table_name;
```


```{sql query4-hint-2}
-- HINT: Your query should look something like this, fill in the blanks:
SELECT faa AS code, name AS ___, alt AS ___
FROM airports;
```


```{sql query4-solution}
-- SOLUTION: Here is how you can select and alias the FAA code, name, and altitude from the airports table:
SELECT faa AS code, name AS airport_name, alt AS altitude
FROM airports;
```


```{r query4-check, echo=FALSE}
grade_this({
  # Execute the solution query to get the correct result for EXERCISE 4
  .solution_ex4 <- DBI::dbGetQuery(con, "SELECT faa AS code, name AS airport_name, alt AS altitude FROM airports;")
  
  # Execute the student's query for EXERCISE 4
  .result_ex4 <- DBI::dbGetQuery(con, .user_code)
  
  # Dynamically get expected columns from the solution for EXERCISE 4
  cols_expected_ex4 <- names(.solution_ex4)
  
  # Check for missing or extra columns in the student's result
  missing_cols_ex4 <- setdiff(cols_expected_ex4, names(.result_ex4))
  extra_cols_ex4 <- setdiff(names(.result_ex4), cols_expected_ex4)
  
  if (length(missing_cols_ex4) > 0) {
    fail(glue::glue("Your query is missing the following columns: {toString(missing_cols_ex4)}."))
  }
  
  if (length(extra_cols_ex4) > 0) {
    fail(glue::glue("Your query should not include the following columns: {toString(extra_cols_ex4)}."))
  }
  
  # Check if the number of rows and values in each column match the solution
  if (nrow(.result_ex4) != nrow(.solution_ex4)) {
    fail("The number of rows returned by your query does not match the expected result.")
  }
  
  all_columns_match_ex4 <- TRUE
  for (column in cols_expected_ex4) {
    if (!identical(sort(.result_ex4[[column]]), sort(.solution_ex4[[column]]))) {
      all_columns_match_ex4 <- FALSE
      break
    }
  }
  
  if (!all_columns_match_ex4) {
    fail("The values returned by your query do not match the expected result in one or more columns.")
  }
  
  # If all checks pass
  pass("Your query appears to be correct.")
})
```

5. Choose the destination airport code and air time from the flights table with an alias

```{sql query5, exercise=TRUE, exercise.eval=FALSE}
-- Write your SQL query here to select the destination airport code and air time from the flights table with an alias
```

```{sql query5-hint-1}
-- HINT: Use the SELECT statement to choose columns and AS to alias the table. For example:
SELECT column_name
FROM table_name AS table_alias;
```

```{sql query5-hint-2}
-- HINT: Your query should include the table alias and select specific columns like this:
SELECT f.dest, f.air_time
FROM flights AS f;
```

```{sql query5-solution}
-- SOLUTION: Here's how to select the destination airport code and air time from the flights table using an alias:
SELECT f.dest, f.air_time
FROM flights AS f;
```

```{r query5-check, echo=FALSE}
grade_this({
  # Execute the solution query to get the correct result for EXERCISE 5
  .solution_ex5 <- DBI::dbGetQuery(con, "SELECT dest, air_time FROM flights AS f;")
  
  # Execute the student's query for EXERCISE 5
  .result_ex5 <- DBI::dbGetQuery(con, .user_code)
  
  # Dynamically get expected columns from the solution for EXERCISE 5
  cols_expected_ex5 <- names(.solution_ex5)
  
  # Check for missing or extra columns in the student's result
  missing_cols_ex5 <- setdiff(cols_expected_ex5, names(.result_ex5))
  extra_cols_ex5 <- setdiff(names(.result_ex5), cols_expected_ex5)
  
  if (length(missing_cols_ex5) > 0) {
    fail(glue::glue("Your query is missing the following columns: {toString(missing_cols_ex5)}."))
  }
  
  if (length(extra_cols_ex5) > 0) {
    fail(glue::glue("Your query should not include the following columns: {toString(extra_cols_ex5)}."))
  }
  
  # Check if the number of rows and values in each column match the solution
  if (nrow(.result_ex5) != nrow(.solution_ex5)) {
    fail("The number of rows returned by your query does not match the expected result.")
  }
  
  all_columns_match_ex5 <- TRUE
  for (column in cols_expected_ex5) {
    if (!identical(sort(.result_ex5[[column]]), sort(.solution_ex5[[column]]))) {
      all_columns_match_ex5 <- FALSE
      break
    }
  }
  
  if (!all_columns_match_ex5) {
    fail("The values returned by your query do not match the expected result in one or more columns.")
  }
  
  # If all checks pass
  pass("Your query appears to be correct.")
})
```

## Unique entries

## View creation

## Counting

# Filtering Techniques

## Filtering rows/records

## Filtering text

# Aggregating Techniques

## Numerical summaries

## Categorical summaries

## Rounding summaries

# Sorting and Grouping Techniques

## Sorting

## Grouping

# Transforming Techniques

# Joining Techniques

## INNER JOIN

## LEFT JOIN

## RIGHT JOIN

## Anti-Join
